#summary the IoC design pattern - Object Definitions in the IoC factory
#labels Documentation,Framework

= B - Object Definitions =

The *IoC* container is initialized with object definitions that are "operating instructions" for creating objects in an application. They also define dependency relationships that can have objects and classes with each other.

The *object definitions* are represented by objects that implement the interface *system.ioc.IObjectDefinition*, this interface is implemented by the class *ObjectDefinition*.

The *IObjectDefinition* interface has the following characteristics :
 * A unique identifier for each object definition (required).
 * A description of the type of object that will be returned or created with the object definition (required).
 * References to the "dependencies" of the object.
 * All the elements that will initialize the object at the time of its creation.
 * All the elements that will control the behavior of an object in the application : its scope, its methods invoked throughout its life cycle, etc.

The concepts listed above correspond to a set of elements in simple *generic objects* that create and initialize the *object definitions* from an *IoC* container.

*usage*

{{{
ObjectDefinition.create( init:Object ):ObjectDefinition
}}}

The *system.ioc.ObjectDefinition* class contains a static method "create" who generate a new instance very simply by switching to a *generic object* parameter initialization compatible with the attributes to be defined next in its chapter. 

It will always be easier to use the static *create()* method to initialize by hand all *ObjectDefinition* instances in your applications.

*example*

{{{
import flash.text.TextField ;
import flash.text.TextFormat ;

import system.ioc.ObjectDefinition ;

var context:Object =
{
    id         : "my_field" ,
    type       : "flash.text.TextField" ,
    properties :
    [
        { name : "defaultTextFormat" , value : new TextFormat("verdana", 11) } ,
        { name : "selectable"        , value : false                         } ,
        { name : "text"              , value : "hello world"                 } ,
        { name : "textColor"         , value : 0xF7F744                      } ,
        { name : "x"                 , value : 100                           } ,
        { name : "y"                 , value : 100                           }
    ]
}

var definition:ObjectDefinition = ObjectDefinition.create( context ) ;

trace( "definition.id              : " + definition.id ) ;
trace( "definition.getType()       : " + definition.getType() ) ;
trace( "definition.getScope()      : " + definition.getScope() ) ;
trace( "definition.isSingleton()   : " + definition.isSingleton() ) ;
trace( "definition.isLazyInit()    : " + definition.isLazyInit() ) ;
trace( "definition.getProperties() : " + definition.getProperties() ) ;
}}}

The *generic object* used to initialize the object definition contains specific attributes. We will discuss later in this chapter about these attributes by dividing them into four distinct groups.

*1 - Basic attributes to create an object definition*

|| *id* (required) || The unique identifier of the object definition. This identifier is a key used to find the reference of the corresponding object in the IoC container. ||
|| *type* (required) || The full name of the type(class) of the object created and returned by the factory. ||
|| *arguments* || A list (Array) of all the arguments in the constructor of the class or also in the methods invoked to initialize the new object. ||
|| *properties* || A list (Array) of all properties initialized after the creation of the object. ||
|| *singleton* || Defines soon the scope "singleton" of the object generated by the factory. ||
|| *scope* || Defines exactly the scope of the new object generated by the factory : "prototype" or "singleton". ||

*2 - Lifecycle of the objects defined and created with an object definition*

|| *identify* || Can identify some Identifiable objects by assigning them automatically the id value of the object definition. ||
|| *lock* || The full name of the type(class) of the object created and returned by the factory. ||
|| *init* || Indicates the name of the method to call to finish to initialize the object. ||
|| *destroy* || Indicates the name of the method to call to destroy a singleton object register in the IoC container. ||
|| *dependsOn* || A list (Array) of objects identifiers registered in the factory who must exist before the current object is generated and initialized. ||
|| *generates* || A list (Array) of objects identifiers registered in the factory who must exist after the current object is generated and initialized. ||
|| *listeners* || A list (Array) of event listeners to register with the current dispatcher object (the object must implement the flash.events.IEventDispatcher interface) ||
|| *receivers* || A list (Array) of signals to connect with the object (if the object implements the system.signals.Receiver interface) or one or more of this methods (slots).||

*3 - The different strategies in the factory to create or target objects*

|| *factoryMethod* || Creates an object with a method defines over a reference defines in the factory with a specific object definition. ||
|| *factoryProperty* || Creates an object with a simple attribute defines over a reference defines in the factory with a specific object definition. ||
|| *factoryReference* || Target an object definition already defined in the factory to generate a new object or modify the existing object. ||
|| *factoryValue* || Allows you to use any value defined directly in the external environment of the factory as a reference in an object definition. ||
|| *staticFactoryMethod* || Creates an object using a static method defines in a class of the application. ||
|| *staticFactoryProperty* || Creates an object using a static attribute defines in a class of the application. ||

*4 - The "evaluators" attribute*

|| *evaluators* || You can use this attribute to filter or transform the values defines in the the attributes "properties" and "arguments". ||

We will define for the rest of the chapter a basic example that illustrate the techniques to define a collection (*Array*) of *generic objects* used to initialize and fill the factory. 

This collection can then be stored in an external text file format like eden or directly in the source code of the *ActionScript* application.

Take the time to create a small *examples.core.User* class to illustrate the dependencies that can have a class with other classes.

{{{
package examples.core
{  
    public class User
    {
        public function User
        ( 
            pseudo:String   = null , 
            name:String     = null , 
            address:Address = null 
        )
        {
            this.pseudo  = pseudo ;
            this.name    = name ;
            this.address = address ;
        }
      
        public var address:Address ;
        
        public var age:Number ;
        
        public var firstName:String ;
        
        public var job:Job ;
        
        public var mail:String ;
        
        public var name:String ;
        
        public var pseudo:String ;
        
        public var url:String ;
        
        public function destroy():void
        {
            trace( this + " destroy.") ;
        }
        
        public function initialize():void
        {
            trace( this + " initialize.") ;
        }
        
        public function setMail( str:String ):void
        {
            mail = str ;
        }
        
        public override function toString():String
        {
            return "[User" + pseudo + "]" ;
        }
    }
}
}}}

We observe in the *User* class notions of dependencies explained in the previous chapter in terms of its *constructor* function, its *attributes* and *methods*.

The *User* class has many dependencies, for example with the *Address* and *Job* classes defined below :

*examples.core.Address :*

{{{
package examples.core
{
    public class Address
    {
        public function Address
        ( 
            city:String   = null , 
            street:String = null , 
            zip:Number    = NaN 
        )
        {
            this.city   = city ;
            this.street = street ;
            this.zip    = zip	;
        }
        
        public var city:String ;
        public var street:String ; 
        public var zip:Number ;
    }
}
}}}

*examples.core.Job :*

{{{
package examples.core
{   
    public class Job
    {
        public function Job( name:String = null )
        {
            this.name = name ;
        }
        
        public var name:String ;
        
        public override function toString():String
        {
            return "[Job " + name + "]" ;
        }
    }
}
}}}

Now let's see an example of *IoC* configuration containing all the *object definitions* which will then used in the lightweight container and to create an instance of the *examples.core.User* class :

{{{
var objects:Array =
[
    {  
        id        	: "address"  ,
        type      	: "examples.core.Address" ,
        properties	:
        [
            { name : "city"   , value : "Marseille" } ,
            { name : "street" , value : "xx xxx xxxxxxxxxxx" } ,
            { name : "zip"    , value : 13001 }
        ]
    }
    ,
    {  
        id     	: "job_dev"   ,
        type   	: "examples.core.Job"  ,
        scope  	: "prototype" ,
        properties : [ { name:"name" , value:"AS Developper" } ]
    }   
    ,
    { 
        id         : "user" ,
        type       : "examples.core.User" ,
        arguments :
        [
            { value : "eKameleon" } ,
            { value : "ALCARAZ"   } ,
            { ref   : "address"   }
        ] ,
        lazyInit   : true , 
        singleton  : true ,
        destroy    : "destroy" ,
        init       : "initialize" ,
        properties :
        [
            { name : "age"       , value : 32        } ,
            { name : "firstName" , value : "Marc"    } ,
            { name : "job"       , ref   : "job_dev" } ,
            { name : "url"       , value : "http://www.ekameleon.net" } ,
            { 
                name : "setMail" , 
                arguments : [ { value : "ekameleon [at] gmail.com" } ] 
            }
        ]
    }
] ;
}}}

The above example does not use all the attributes defined at the beginning of this chapter, but shows the most important features of an *object definition*.

It remains only to initialize the factory and retrieve the object defined in the factory with a basic *ActionScript* code :

{{{
import system.ioc.factory ;

import examples.core.User ;

factory.run( objects ) ;

var user:User = factory.getObject( "user" ) as User ;

trace( user ) ;
}}}

We will use much of this example in the descriptions of the attributes that follow. 

== 1 - Basic attributes to create an object definition ==

=== 1.1 - The "id" attribute ===

This identifier is the "*unique key*" required to defines a new *object definition* in the *IoC* container.

*example*

{{{
{ 
    id : "user" ,
    …
}}}

Now look at how to use the unique identifier of an object definition to create and get the corresponding object reference in the factory.

{{{
var user:User = factory.getObject( "user" ) as User ;
}}}

The "*id*" attribute is essential to create or to get an object with the *getObject()* method.

*Hint* : I often use in my projects enumerations with a specific class who contains static constants who define a list of all important object definitions registered in the factory.

For example we can create a list of the main views of an application by quickly creating a small class *DisplayList* : 

{{{
package example
{
    public class DisplayList
    {
        public static const BACKGROUND:String = "background" ;
        
        public static const BODY:String = "body" ;
        
        public static const MENU:String = "menu" ;
    }
}
}}}

Then we can create an *IoC* configuration context with the *object definitions* :

{{{
var objects:Array =
[
    {
        id    	: "background"  ,
        type  	: "flash.dislay.Sprite" ,
        singleton : true 
    }
    ,
    {
        id    	: "body"  ,
        type  	: "flash.dislay.Sprite" ,
        singleton : true 
    }
    ,
    {
        id    	: "menu"  ,
        type  	: "flash.dislay.Sprite" ,
        singleton : true 
    }
] ;
}}}

To call at any time a singleton object defined above, simply type the following code :

{{{
import system.ioc.factory ;
import example.DisplayList ;
import flash.display.Sprite ;

factory.run( objects ) ;

var background:Sprite = factory.getObject( DisplayList.BACKGROUND ) as Sprite ;
}}}

=== 1.2 - The "type" attribute ===

This attribute is mandatory and usually indicates the full name of the *class* (or type) of the object that you want to create or target in the factory (in the case of a "*singleton*" reference).

{{{
    type : "examples.core.User" ,
}}}

Make sure that the class exists in the main file of the application. If this class does not exist, it is possible to include this class (or graphics,sounds, etc..) Using the engine to load external resources of the factory IoC common. Otherwise it will force the existence of this class by calling at least once in the main application code.

Note that the expression (*String*) of this attribute can be subjected to filtering and formatting using tools passed in the configuration of the factory. These assessments and filtering can greatly simplify the writing of your *object definitions*.

*Note :*  With an *object definition* who defines a custom strategy who changes the classical strategy used by default in the lightweight container, the object generated with this custom strategy can be defines with a _different_ type from that defined in the definition but will keep a "casting" compatible with the class set with the attribute "*type*".

The object must *implements* or *extends* the type (interface or class) defined in this *object definition*. The key word "*as*" is used in the factory just after the creation of a new object and ensures that the object created has the correct type. In case of problems and incompatibilities on typing defined in the object definition with the type of the object created by the factory, the container will return a *null* object.

=== 1.3 - The "arguments" attribute ===

The attribute "*arguments*" is a list (*Array*) of generic objects who defines the parameters that you want to inject in the constructor function for a class or a method.

This attribute can be used at the root of an object definition, then it corresponds to the parameter list of the constructor function of the class used to create the object, otherwise it match the argument list the you want to inject in a setter method (eg in the attribute "*properties*").

This attribute is optional, any method or constructor function defined without this attribute can be invoked with no parameters.

This attribute allow you to create and initialize *system.ioc.ObjectArgument* objects in the factory.

This class includes mainly the following members :

 * *value* : Refers to the value or reference of the argument. This attribute can either be the value of the argument, an expression (String) to be interpreted by the factory.
 * *policy* : Defines the strategy used by the factory to create the argument, it determines if the argument is defined with a single value, a reference to another object definition, etc.
 * *evaluators* : (optional) Set in a very special collection of objects of evaluation that will be used to filter or transform the value or the reference.

To transform a simple list (*Array*) of generic objects into a list (*Array*) of *ObjectArgument* objects the framework use a single function : 

*usage*

{{{
system.ioc.builders.createArguments( init:Object )
}}}

*example*

{{{
import system.ioc.builders.createArguments ;

import system.ioc.ObjectArgument ;
import system.ioc.ObjectAttribute ;

var list:Array =
[
    { value  : "hello world"  } ,
    { ref    : "my_id"        } ,
    { config : "config.value" } ,
    { locale : "locale.value" } ,
    { value  : "hi world" , evaluators:["myEvaluator"] } 
] ;

var args:Array = createArguments( list ) ; 

trace( "args: " + args ) ;

var arg:ObjectArgument = args[4] as ObjectArgument ;

trace( "value:" + arg.value + " evaluators:" + arg.evaluators ) ;
}}}

To respect the "*hollywood principle*" this function is encapsuled and used by the framework when you initialize your *object definitions* in the factory with the *run()* method.

The *generic objects* must absolutely be defined with a mandatory attribute specific to be transformed into an *ObjectArgument* object otherwise it will not be included in the method *createArguments()* and will be replaced by a *null* value.

We can see in the example above that all objects are defined with a specific attribute :
 * value
 * ref
 * config
 * local

These attributes correspond to the possible values ​​of the attribute "*policy*" of the class *ObjectArgument*. The static enumeration defines with the *system.ioc.ObjectAttribute* class defines all the policies accepted in the  *ObjectArgument* class :

 * ObjectAttribute.VALUE 	  : "value"
 * ObjectAttribute.REFERENCE : "ref"
 * ObjectAttribute.CONFIG	  : "config"
 * ObjectAttribute.LOCALE	  : "locale"

Each of the constants defines above provide the necessary information to generate a new argument with a specific "policy" in the container.

Now, let the main example of this chapter by isolating the "*arguments*" attribute in the object definition "*user*".

{{{
{ 
    id         : "user" ,
    type       : "test.User" ,
    arguments  :
    [
        { value : "eKameleon" } ,
        { value : "ALCARAZ"   } ,
        { ref   : "address"   }
    ]
}
}}}

The arguments are defined by generic objects which usually contain an attribute "*value*" or attribute "*ref*". Only one of these attributes can be used for a single generic object. These attributes are used to define the value of an argument by value or reference to target a specific object definition in the *IoC* container.

The above example can be translate in *ActionScript* with the code :

{{{
var user:User = new User("eKameleon","ALCARAZ",factory.getObject("address")) ;
}}}

Used in the attribute "*properties*", the attribute "*arguments*" will be considered by the container only if the property defined in one of the generic objects in the collection will be of type "*Function*" (method defined in the factory).

*example*

{{{
properties :
[
    { name:"setMail" , arguments:[ { value:"ekameleon[at]gmail.com" } ] }
]
}}}

This very simple example can set the attribute "*properties*" with a method "*setMail*" that will be invoked during the initialization process of the new object in the factory.

*Note* 

We can replace the classical attributes "*value*" and "*ref*" with two specials attributes : "*config*" or "*locale*". This attributes are used to evaluate the argument and to retrieve a value localized or set in the config object of the application.

==== 1.3.1 - The "value" attribute. ====

This attribute in the arguments definitions is the most simple.

{{{
    { value : "eKameleon" } ,
}}}

This attribute defines an argument with a simple value of any type.

==== 1.3.2 - The "ref" attribute. ====

This attribute defines a String expression who target a unique identifier register in the container.

{{{
    { ref : "address" } ,
}}}

This attribute defines the dependency injection between the objects defined in the container.

In our example the reference "*address*" will be use to create the dependency with the method *getObject("address")* of the factory and to initialize the object who needs it to exist.

All the "*ref*" attributes in the *object definitions* are the same operation mode. I will try here to generalize the use of this attribute.

This attribute is set to an expression (String) evaluated in the factory for a *system.ioc.evaluators.ReferenceEvaluator* instance. 

The *ReferenceEvaluator* class target a specific *IoC* factory and analyzes a *String* expression to identify an *object definition* register in the factory and return immediately the reference of the corresponding object.

If the expression is defined with a dot notation, it will be possible to target an object in the factory and get the value of one of its members, example :

{{{
    { ref : "address.city" }
}}}

In our example the argument target the reference defines with the expression *"address.city"* and returns the value *"Marseille"*.

It's possible to use a dot notation to find a value set deeper into the attributes of the object, eg: *"foo.bar.xxxx.name"*.

The "*ref*" attribute can be defined also with the "*magic expressions*", these special strings can target by reference certain important object predefined in the configuration of the *IoC* factory.

|| *#config* || Targets a specic reference defines in the configuration object of the factory. ||
|| *#locale* || Targets a specic reference defines in the configuration object of the factory with a notion of localization. ||
|| *#this* || Targets the local IoC factory reference of the current object definition. ||
|| *#root* || Targets the "root" reference, can be the main timeline of the current application. ||
|| *#stage* || Targets the "stage" reference of the current application defines in the config of the factory. ||
|| *#params* || Targets the "parameters" reference of the application defines in the config of the factory. ||

// TODO