#summary the IoC design pattern -Hollywood principle
#labels Documentation,Framework

= Inversion of Control =

== A - Generality ==

=== 1 - Definitions === 

==== Dependency Injection ====

The *Dependency Injection* (DI) refer to the process of supplying code in an existing application. Classes are not responsible in the instantiation of the other classes they need. Objects are *injected* when the instance is initialised.

This *Design Pattern* use many classes or objects that work together. We can also talk about the notion of dependency between objects. There are many ways to use this design pattern. Let's have a closer look to the different types of dependency injection in object oriented code.

*Hard-coding dependencies*

The class create its own dependency. This method is the most simple to handle dependency but it is also the less flexible.

{{{
package
{
    public class Writer
    {
        public function Writer(){}
        
        public function write( message:String ):void
        {
            ( new Pen() ).write( message ) ;
        }
    }
}
}}}

In the previous example the class *Writer* use in its method *write( message:String )* an object of type *Pen*. This method is hence dependent of an object of type *Pen*.

The code has a very simple effect but creating directly the object of type *Pen* in the method limit the possibilities of the class and its future evolutions. In case the *Pen* class change we also have to modify the writer class with is not very convenient.

*Looking up dependencies*

This method needs a context. The class call an object and use its method as needed. The context is an external object that handle all the dependencies.

{{{
package
{
    public class Writer
    {
        public function Writer(){}
       
        public function write( message:String ):void
        {
            var context:Tools = new Tools() ;
            
            context.getPen().write( message ) ;
        }
    }
}
}}}

*Constructor injection*

This method is a simple and classical approach. Here the model use a class with constructor and parameters for each dependency. Dependencies are set when the class is instantiated.

{{{
package
{
    public class Writer
    {
        public function Writer( pen:Pen )
        {
            _pen = pen ;
        }
       
        protected var _pen:Pen ;
        
        public function write( message:String ):void
        {
            _pen.write( message ) ;
        }
    }
}
}}}

Here the constructor of the class inject a reference of type *Pen* that allow the *write()* method to work correctly.

*Setter injection*

Here dependencies are set through the public properties of the class. The dependencies are set after the creation of the object.

Example with a simple public attribute :

{{{
package
{
    public class Writer
    {
        public function Writer() {}
        
        public var pen:Pen ;

        public function write( message:String ):void
        {
            if( pen )
            {
                pen.write( message ) ;
            }
        }
    }
}
}}}

Example with a simple public setter method :

{{{
package
{
    public class Writer
    {
        public function Writer() {}
        
        protected var pen:Pen ;
        
        public function setPen( p:Pen ):void
        {
            this.pen = p ;
        }
        
        public function write( message:String ):void
        {
            if( pen )
            {
                pen.write( message ) ;
            }
        }
    }
}
}}}

The *setPen()* method inject the dependency in the Write object this can be any object of type *Pen* in order to have the *write()* method working correctly.

Example with a simple public virtual accessor :

{{{
package
{
    public class Writer
    {
        public function Writer() {}
        
        protected var _pen:Pen ;
        
        public function get pen():Pen
        {
            return _pen ;
        }

        public function set pen( p:Pen ):void
        {
            _pen = p ;
        }
        
        public function write( message:String ):void
        {
            if( _pen )
            {
                _pen.write( message ) ;
            }
        }
    }
}
}}}

The virtual property "pen" inject in the Write object any object of type *Pen* i order to have the *write()* method working correctly.

*Interface injection*

This approach is the same as *setter injection* or *constructor injection* but here the dependency is typed with an interface :

{{{
package
{
    public class Writer
    {
        public function Writer() {}
        
        protected var _pen:IPen ;
        
        public function get pen():IPen
        {
            return _pen ;
        }

        public function set pen( p:IPen ):void
        {
            _pen = p ;
        }
        
        public function write( message:String ):void
        {
            if( _pen )
            {
                _pen.write( message ) ;
            }
        }
    }
}
}}}

In its example *IPen* is an interface who defines the public method *write()*.

{{{
package
{
    interface class IPen
    {
        function write( message:String ):void ;
    }
}
}}}

This solution is very flexible and lightweight because it does not develop immediately a class more or less complex to instantiate instances of class *"Write"*. The dependency is defined simply about a behavior.
