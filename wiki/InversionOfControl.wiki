#summary the IoC design pattern - Hollywood principle
#labels Documentation,Framework

= Inversion of Control =

== A - Generality ==

=== 1 - Definitions === 

==== Dependency Injection ====

The *Dependency Injection* (DI) refer to the process of supplying code in an existing application. Classes are not responsible in the instantiation of the other classes they need. Objects are *injected* when the instance is initialised.

This *Design Pattern* use many classes or objects that work together. We can also talk about the notion of dependency between objects. There are many ways to use this design pattern. Let's have a closer look to the different types of dependency injection in object oriented code.

*Hard-coding dependencies*

The class create its own dependency. This method is the most simple to handle dependency but it is also the less flexible.

{{{
package
{
    public class Writer
    {
        public function Writer(){}
        
        public function write( message:String ):void
        {
            ( new Pen() ).write( message ) ;
        }
    }
}
}}}

In the previous example the class *Writer* use in its method *write( message:String )* an object of type *Pen*. This method is hence dependent of an object of type *Pen*.

The code has a very simple effect but creating directly the object of type *Pen* in the method limit the possibilities of the class and its future evolutions. In case the *Pen* class change we also have to modify the writer class with is not very convenient.

*Looking up dependencies*

This method needs a context. The class call an object and use its method as needed. The context is an external object that handle all the dependencies.

{{{
package
{
    public class Writer
    {
        public function Writer(){}
       
        public function write( message:String ):void
        {
            var context:Tools = new Tools() ;
            
            context.getPen().write( message ) ;
        }
    }
}
}}}

*Constructor injection*

This method is a simple and classical approach. Here the model use a class with constructor and parameters for each dependency. Dependencies are set when the class is instantiated.

{{{
package
{
    public class Writer
    {
        public function Writer( pen:Pen )
        {
            _pen = pen ;
        }
       
        protected var _pen:Pen ;
        
        public function write( message:String ):void
        {
            _pen.write( message ) ;
        }
    }
}
}}}

Here the constructor of the class inject a reference of type *Pen* that allow the *write()* method to work correctly.

*Setter injection*

Here dependencies are set through the public properties of the class. The dependencies are set after the creation of the object.

Example with a simple public attribute :

{{{
package
{
    public class Writer
    {
        public function Writer() {}
        
        public var pen:Pen ;

        public function write( message:String ):void
        {
            if( pen )
            {
                pen.write( message ) ;
            }
        }
    }
}
}}}

Example with a simple public setter method :

{{{
package
{
    public class Writer
    {
        public function Writer() {}
        
        protected var pen:Pen ;
        
        public function setPen( p:Pen ):void
        {
            this.pen = p ;
        }
        
        public function write( message:String ):void
        {
            if( pen )
            {
                pen.write( message ) ;
            }
        }
    }
}
}}}

The *setPen()* method inject the dependency in the Write object this can be any object of type *Pen* in order to have the *write()* method working correctly.

Example with a simple public virtual accessor :

{{{
package
{
    public class Writer
    {
        public function Writer() {}
        
        protected var _pen:Pen ;
        
        public function get pen():Pen
        {
            return _pen ;
        }

        public function set pen( p:Pen ):void
        {
            _pen = p ;
        }
        
        public function write( message:String ):void
        {
            if( _pen )
            {
                _pen.write( message ) ;
            }
        }
    }
}
}}}

The virtual property "pen" inject in the Write object any object of type *Pen* i order to have the *write()* method working correctly.

*Interface injection*

This approach is the same as *setter injection* or *constructor injection* but here the dependency is typed with an interface :

{{{
package
{
    public class Writer
    {
        public function Writer() {}
        
        protected var _pen:IPen ;
        
        public function get pen():IPen
        {
            return _pen ;
        }

        public function set pen( p:IPen ):void
        {
            _pen = p ;
        }
        
        public function write( message:String ):void
        {
            if( _pen )
            {
                _pen.write( message ) ;
            }
        }
    }
}
}}}

In its example *IPen* is an interface who defines the public method *write()*.

{{{
package
{
    interface class IPen
    {
        function write( message:String ):void ;
    }
}
}}}

This solution is very flexible and lightweight because it does not develop immediately a class more or less complex to instantiate instances of class *"Write"*. The dependency is defined simply about a behavior.

==== Inversion of Control ====

The design pattern *Inversion of Control*, also called *IoC* (another name for *Dependency Injection*) define a set of programming technique where the flow of system control and its objects are reversed from the usual flow.

This concept is based on the "[http://en.wikipedia.org/wiki/Hollywood_Principle Hollywood Principle]" : *Don't call us, we will call you*.

The main principle is simple, it indicates an application framework that does not need to be called to run the application, the framework itself which is responsible for creating the interactions between objects (whenever it's possible).

<img src="http://maashaack.googlecode.com/files/ioc_hollywood_principle.gif" align="middle" />

This model highlights the concept of *Programming Layers*. This concept allows to separate each element of an application and work with each independently and then tie them together very simply by having the fewest dependencies as possible at the outset. So the framework to link each layer with each other in time by injecting any dependencies in the object that needs it.

==== Container based on Inversion of Control ====

An *Inversion of Control* container is an application infrastructure that feed numerous services need in order to have the application running.

The main services of an *IoC* container classic are :

*Lookup*

The container store or create reference for every objects in the application. it can also be seen as a factory for the application.

*Lifecycle management*

The *lifecycle* of the objects is handled by the container. It can create new objects, automatically inject predefined values in properties of a new instance when it is created, call method when the object is initialised or destructed, etc.

*Configuration*

Objects can be configured through external data without having to rebuild the application; it is possible to use external data with the following formats *eden*, *JSON*, *XML*, ... to create or initialise the application.

*Dependency Injection*

Containers are not limited to handling and configuring objects with simple types, they can also handle link and dependency between objects.

==== Object definitions in the IoC containers ====

An *object definition* is an object that will create a new object in an application with the *IoC* factory. The *object definition* can be regarded as a manual or a guide predefined by the developers of the application using this container.

This manual may contain :

 * an identifier that can save its definition and then create objects,
 * the type of the object that we want to create,
 * the parameters that one wishes to spend in the constructor,
 * the default values that you want to apply on the object (properties and methods),
 * the method name that you want to invoke once the object is created to initialize it,
 * inject dependencies with other objects defined also in the factory,
 * etc.

The *object definition* can provide further information on the strategy used by the factory to create the object or the nature of this object in the life cycle of the application like the scope of the object : singleton or prototype.

If one were reduced to its simplest form the definition of an *IoC* container, we could say that it consists of a collection of *object definitions* to structure effectively and solid applied throughout its life cycle.

=== 2 - The ObjectDefinitionContainer class ===

The *system.ioc* package contains all important classes and interfaces to deploy the inversion of control pattern in your applications. The *system.ioc* package is dependent on the *core* and *system* packages.

The kernel class in the *system.ioc* package defines the *lightweight container* implementation with the *IObjectDefinitionContainer* interface. This class is the super class of the *ObjectFactory* class.

*members inspection*

|| *Members* || *Description* ||
|| numObjectDefinitions:Boolean || Indicates the numbers of object definitions registered in the container. ||
|| addObjectDefinition(id:String, definition:IObjectDefinition ) || Registers a new object definition in the container. ||
|| clearObjectDefinition() || Removes all the object definitions in the container. ||
|| clone():* || Returns a shallow copy of the object. ||
|| containsObjectDefinition(id:String) || Returns true if the object defines with the specified id is register in the container. ||
|| getObjectDefinition(id:String) || Returns the object definition register in the container with the specified id. ||
|| removeObjectDefinition(id:String)	|| |Unregisters a specific object definition in the container. ||

*example*

{{{
import flash.text.TextField ;
import flash.text.TextFormat ;

import system.ioc.ObjectDefinition ;
import system.ioc.ObjectDefinitionContainer ;
import system.ioc.ObjectFactory ;

var container:ObjectDefinitionContainer = new ObjectFactory();
 
var context:Object =
{
    id         : "my_field" ,
    type       : "flash.text.TextField" ,
    properties : 
    [
        { name : "defaultTextFormat" , value : new TextFormat("verdana", 11) } ,
        { name : "selectable"        , value : false                         } ,
        { name : "text"              , value : "hello world"                 } ,
        { name : "textColor"         , value : 0xF7F744                      } ,
        { name : "x"                 , value : 25                            } ,
        { name : "y"                 , value : 25                            }         
    ]
}

var definition:ObjectDefinition = ObjectDefinition.create( context ) ;

container.addObjectDefinition( definition );

trace( container.containsObjectDefinition( "my_field" ) ) ; // true
trace( container.getObjectDefinition( "my_field" ) ) ; // [ObjectDefinition]
trace( container.numObjectDefinitions ) ; // 1

var field:TextField = (container as ObjectFactory).getObject("my_field") as TextField ;
}}}

In this example we initialize an object definition with a single generic object that will generate with the factory a specific instance of the TextField class. This simple technique can be injected at any time of the new definitions of objects by hand in the factory with the method *addObjectDefinition()*.

=== 3 - The ObjectFactory class ===

The *ObjectFactory* class is the main class of the dependency injection engine defines in the *system.ioc* package. This class defines in the same object a container and a factory used in the application to create all objects and dependencies between them.

This class has a rich heritage, with several levels of inheritance, which provides several important features :

ObjectFactory 
    |_ObjectDefinitionContainer 
        |_CoreAction
            |_Task

This class implements the interfaces :
 * *system.Cloneable* : use the classical clone() method to generate a shallow copy of the factory.
 * *system.process.Runnable* : Initialize the content of the factory with the basic run method (design pattern Command).
 * *system.process.Action* : The factory can be initialize in a global process and can be include in a sequence or batch group of complex processes.
 * *system.process.Lockable* : Lock the singleton lazy initialize process.
 * *system.ioc.IObjectDefinitionContainer* : defines all the methods to create and manage the object definitions in the container.
 * *system.ioc.IObjectFactory* : defines all the methods to create and manage the objects in the factory.

*usage*

{{{
new ObjectFactory( config:ObjectConfig = null , objects:Array = null )
}}}

*example*

I will illustrate the use of the factory based *IoC* with a simple collection of generic objects defined in an *Array* object.

These generic objects allow the initialization and the injection of several *object definitions* in the factory and allow the automatic creation of objects with a "*singleton*" scope during the initialization of the lightweight container. 

{{{
import system.ioc.ObjectFactory ;

var objects:Array =
[
    {
        id    	: "my_format" ,
        type  	: "flash.text.TextFormat" ,
    	  arguments : 
        [ 
            { value :"Arial"   } , 
            { value :24        } , 
            { value : 0xFEF292 } , 
            { value : true     } 
        ]
    }
    ,
    {
        id         : "my_field" ,
        type   	 : "flash.text.TextField"  ,
        properties :
        [
            { name : "autoSize"          , value  : "left"        } ,
        	{ name : "defaultTextFormat" , ref    : "my_format"   } ,
        	{ name : "text"              , value  : "HELLO WORLD" } ,
        	{ name : "x"                 , value  : 10            } ,
        	{ name : "y"                 , value  : 10            }
    	]
    }
    ,
    {
        id           	 : "root" ,
        type         	 : "flash.display.MovieClip"  ,
        factoryReference : "#root" ,
        singleton    	 : true ,
        properties       :
        [
            { name : "addChild" , arguments : [ { ref:"my_field" } ] }
        ]
    }
] ;

var factory:ObjectFactory = new ObjectFactory() ;

factory.config.root = this ;

factory.run( objects ) ; 
}}}

In the previous example the generic object "*objects*" is a basic *Array* who defines the setting of the *IoC* factory with tree *object definitions* :

 * *my_format* : this definition defines a specific setting to create *flash.text.TextFormat* instances with the factory. This definition use a *constructor injection* to initialize the new object.
 * *my_field* : this definition defines a specific setting to create *flash.text.TextField* instances. This definition use a *setter injection* to initialize the new object.
 * *root* : this definition creates a singleton reference in the application who target the main timeline reference defines in the IoC factory configuration. This definition use *setter injection* to attach a reference defines with the object definition "*my_field*".


The object definition "*root*" use a specific strategy defines in the *IoC* factory to target the main timeline reference of the application. The *IoC* factory must target the main timeline manually with the script :

{{{
factory.config.root = this ;
}}}

We initialize the *factory.config.root* property of the factory to allow the *#root* magic reference in the *object definitions* of the *IoC* container.

The *IoC* factory has several types of strategies to create an object in the application with an object definition. We will discuss in the next chapter on object definitions.

The above example will display very fast a *TextField* on the stage of an animation. 

This example illustrates the use of a "_programming layers_" which can isolate each object of an application and work quietly on each of them regardless of their dependencies with each other.

The lightweight container and the framework are responsible for creating the objects and put them in touch with each other.