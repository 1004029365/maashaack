#summary interfaces in AS3.
#labels Code,AS3

== Introduction ==

{{{
Interfaces provide a way for programs to express contracts between the producers and consumers of objects.
These contracts are type safe, easy to understand, and efficient to implement.
Programs should not have to pay a significant performance penalty for using interfaces.

An interface is a type whose methods must be defined by every class that claims to implement it.
Multiple interfaces can be inherited by another interface through the extends clause or by a class through the implements clause.
Instances of a class that implements an interface belong to the type represented by the interface.
Interface definitions must only contain function definitions, which may include get and set methods.

Interface methods are not public by default, but are added to the public namespace
by the implementing method definition.
}}}

see [http://livedocs.adobe.com/specs/actionscript/3/as3_specification95.html Interfaces (AS3 spec)]


== Details ==

Most of the time you will want to see an interface as a type, and based on that you would want to ditch the *I* in front of the name.

See *Architectural Atrocities, Part 5: Interfaces in AS3* [#2 |2|], for a long discussion about that touchy subject.

My take on that is that I can accept a capital *I* in the name of an interface when we consider a template,
but for a type I will bust your balls till you capitulate and remove the *I*.

Yes, you don't need to put a capital *I* everywhere, and here some basic examples.

=== Basics use ===

Let's say that in your code you want a *Serializable* type<br>
so when you see an object that implement the interface you could say
{{{
my object is Serializable
}}}

what is the contract of a Serializable object ?
{{{
package
{

    public interface Serializable
    {
    
    }

}
}}}

with just that for every class implementing the interface you could test
{{{
trace( myobject is Serializable )
}}}

yes, you don't really need to define functions in this interface as your main concern is to be able to classify a type

Now if you want to enforce a contract, as
{{{
if you are of a type Serializable you have to respect a predefined behaviour
}}}

the definition of the contract will be the definition of the methods you add to an interface
{{{
package
{

    public interface Serializable
    {
        function toSource( indent:int = 0 ):String;
    }

}
}}}

eg.
  * you have to define a toSource method
  * this method have to return a string type
  * this method have one optional argument of type integer

that's the contract to respect to be considered of the *Serializable* type

=== Some Thoughts ===

When you're programming in a framework context you will want to use interfaces to define common behaviours,
here with maashaack we use *Serializable*, *Serializer*, etc.

Don't do that if you plan to have only one serializer, but do use interfaces if you want to define
a general serializer behaviour and have different implementation of it (a eden serializer, a WDDX serializer, a JSON serializer, etc.)

If you're programming in a public API context using interfaces is THE way to go,
you should even consider your interfaces being the API.<br>
Yes, even if you have only one implementation of the interface.<br>
You want the users of the public API to programm their code based on the interfaces, not the implementation.

This is very well explained in *Program to an interface, not an implementation* [#1 |1|].

But you should be aware of certain traps.

As soon as you put a public API out there, you can not change it.<br>
Well... you can not change the interfaces, but you can change the implementation.

Ok I lied a bit, you can change the interfaces, but you can not break them.<br>
And here come the biggest trap: how to version an API.

First, there are no rules and many many many ways of doing it.<br>
(I speak from my small experiences with Google Analytics and Miniclip, comments/critics welcome)

Here what may happen to your public API
  * on one side you gonna provide services to use publicly for your users
  * on the other side you'll have to update the implementation to correct bugs, add features, etc.

the best way imho to do that is to allow yourself to add but never remove anything.<br>
So your API can evolve, but not break older version or put another way: be backward compatible.

so here the basic rules for a public API (wether you have 100 or 10000 users)
  * always define interfaces for everything that your user can use (the public side)
  * never give access to the implementation (the private side)
  * never remove anything from your interfaces
  * use builtin types in your interfaces and/or other interfaces (don't use custom types)
  * be careful how you define your interfaces and how you add to it
  * if you want to give access to a single object (as an entry point), define an interface for it<br>and by extension use getter/setter to define properties for this object

for the versioning in itself I would favour versioning the implementations and keep the interfaces without versioning, but this can be done in a lot of different ways so this will highly depends on your needs (and your users needs).

=== Defining a public API ===

So for example sake,<br>
let's say we have a brand name *Kiki's delivery* which is also a website with some services<br>
and we want to provide access to those services via a public API.

Our use case is that *Kiki's delivery* is a gift delivery services and our main goal is to allow
any developers using our public API to deliver gifts by providing a gift number.

Here the plan:
  * we want *Kiki* to be an entry point
  * we want to provide a *services* interface
  * so at the end your user can do `Kiki.services.doSomething()`

let's define our interfaces
{{{
package kiki
{
    public interface KikiAPI
    {
        function get version():String;
        function get services():Services;
    }
}
}}}
{{{
package kiki
{
    public interface Services
    {
        function deliver( id:Number ):void;
    }
}
}}}

how your user will use it like that ?
{{{
var kiki:KikiAPI = new KikiAPIImplementation();
       kiki.services.deliver( 123 );
}}}

It's kind of bad as you have to give access to * KikiAPIImplementation* so the user can initialize your entry point.<br>
Also *KikiAPI* is not a very good name imho.

Here come the use of the [Singleton] to define your entry point and hide the implementation to your users.<br>
Let's rename *KikiAPI* to just *Kiki*
{{{
package kiki
{
    public interface Kiki
    {
        function get version():String;
        function get services():Services;
    }
}
}}}
then let's do an internal implementation of it
{{{
package kiki
{
    public class _Kiki implements Kiki
    {
        //...
    }
}
}}}
and finally provide an entry point for it
{{{
package kiki
{
    public const KikiDelivery:Kiki = new _Kiki();
}
}}}


now for your users, the use of the public API would be like that
{{{
import kiki.KikiDelivery;

KikiDelivery.services.deliver( 123 );
}}}

Very basic to implement and to use, and never your user need to know about your internal implementation.<br>
Tomorrow you can fix a dozen of bugs, you just keep the same interfaces and release a v1.1 update.

But after tomorrow your users are demanding and they ask to be able to deliver a gift with a card so they can put a friendly message on it.

Time to update your services interface
{{{
package kiki
{
    public interface Services
    {
        function deliver( id:Number, message:String = "" ):void;
    }
}
}}}

and your users can now use it
{{{
import kiki.KikiDelivery;

KikiDelivery.services.deliver( 123, "from russia with love" );
}}}

Even if the example is over-simplified, I hope you can still see where numerous problems can occurs
  * you could have a good half of your users not updating their app to the last API version
  * you have to deal in parallel with user using API v1.0 and user using API v2.0
  * if you don't give a default value for the message, you end up breaking old code that does not use the message property


so here *few tips* from various experiences:

*1.* always define a version of your API, but don't use the version number in the interface name

{{{
package kiki
{
    public class _Kiki implements Kiki
    {
        //...
        public function get version():String
        {
            return "1.0"; //yeah as simple as that is enougth
        }
    }
}
}}}

as a personal favorite I like to define an *API* class combined with an include file<br>
(you can reuse the include in an Ant build and use the rev number under SVN)

*version.propertie*
{{{
version.major = 1
version.minor = 0
version.build  = 0
}}}

*API.as*
{{{
package kiki
{
    public class API
    {
        public static var version:Version = new Version()
        include "version.properties"
        version.revision = "$Rev: 1234 $ ".split( " " )[1];
    }
}
}}}
and in your implementation
{{{
package kiki
{
    public class _Kiki implements Kiki
    {
        //...
        public function get version():String
        {
            return API.version.toString();
        }
    }
}
}}}

why ?

for support, if you go into providing a public API you gonna have to support it<br>
and so if one of your user end up wit ha problem, you want to be able to ask<br>
please trace !KikiDelivery.version and give me the number so you can check on your implementations<br>
to see if it's a bug or something is badly documented, etc.

Depending on how much different version of the API, how many users you supports, etc.<br>
you will feel lucky if the user problems can be solved by just updating the API to the last version ;)


*2.* if you really have to use an object as an entry point for your API

Combine a Singleton and an Interface at the package level<br>
and use a Factory to initialize this main object

small example
{{{
package kiki
{
    public class _Kiki implements Kiki
    {
        public function _Kiki()
        {
            _factory();
        }

        private function _factory():void
        {
             _services = new KikiServices();
        }

        public function get version():String
        {
            return API.version.toString();
        }

        public function get services():Services
        {
            return _services;
        }
    }
}
}}}

{{{
package kiki
{
    public const KikiDelivery:Kiki = new _Kiki();
}
}}}

This will work pretty well if your API does not interact with display objects,
also defining a constant at the package level will create your object pretty early in the stack.

why ?

In term of API, giving access to an entry point allow you to get away with a lot of things
while keeping your code simple to use for your users.

In the documentation, defining one line to import and use the properties is much much simpler to explain<br>
than initialize a factory, how to use events, wait for them, pass references, etc.


*3.* if your main entry point object need a stage reference don't use a singleton at all

Directly provide the Factory to build the instance anywhere, something that will look like that
{{{
var myKiki:Kiki = new KikiDelivery( stage, any, other, options );
}}}

Notice the type, myKiki is the interface Kiki, not the class !KikiDelivery.

Sure it is less user friendly on the API side, but the way the display objects work if you really need
that stage reference you're kind of stuck.

why ?

Let be clear, I'm not pro or against singletons, but if your main point is to give something simple to use to your users<br>
you gonna have to deal with a lot of complex things in the background to do just that: make things simple to use.

But in the process you may end up fighting with Flash, and having access to the stage reference is one of those fights<br>
and it goes like that: on one side the only way to get this stage reference is to be an initialized display object on the display list<br>
there is no other way, period.<br>
and on the other side, you'll have to explain countless time to your user how to provide this stage reference,<br>
which after few thousands time, tons of documentation, wiki pages etc. can be painfull


*4.* know your users (or at least try)

There are various ways to distribute an API
  * simple SWC (code only)
  * source code templates
  * Flash Component (visual SWC)
  * Flex Component (visual SWC)
  * MXP
  * external SWF to load
  * etc.

and *even more way your users will want to use this API*

why ?

you can not plan in advance how the users will use your API<br>
you can try, but it is almost granted that you'll have to update your code and evolve the API<br>
one way or another

this send back to *1.*, you'll have to deal with versioning, branching, etc.


So for the little story,<br>
when we worked on the [http://code.google.com/p/gaforflash/ gaforflash] project we thought that the final users<br>
would want to either use the Flash or Flex component and not use the *code only* version at all<br>
we made the code only version for us, as we prefer to deal with code directly,<br>
and it happen that a lot of people prefer the code only version.

For another little story on another project,<br>
we discovered that people wanted to drop a SWC in their Flash IDE library and have code completion in Flash<br>
and so to support that we had to create a small command line tool to parse the raw asdoc xml to generate Flash IDE xml documentation<br>
and by extension, the SWC was not enougth for Flash IDE, we had to package all that in an MXP,<br>
but ultimately the user didn't need any visual to use the API, they wanted to use code and have code completion.

*conclusion*

For the specific case of a public API, or an API consumed by users in general, the interfaces are your friend.

If you really follow the *hide the implementations, show the interfaces* basic principle you should be able to avoid the basic versioning problem traps.

But imho, using interfaces does not solve completely the versioning problems, you will have to be more creative to deal with that.



=== Versioning interfaces ===

TODO

In some cases, you could version your interfaces by using inheritance.<br>
But don't think it as versioning by numbers, better see it as versioning per layer.

Let's say you have a public API that you want to separate in two categories: free and professional.

The professional version being a more advanced paying version of the API.

You could organize your interfaces with inheritance

first you define an empty interface for your base type
{{{
package company
{
    public interface ChatServer
    {
    
    }
}
}}}

then your basic interface for the free version
{{{
package company
{
    public interface ChatServerBasic extends ChatServer
    {
        
    }
}
}}}

and a pro interface for the more advanced version
{{{
package company
{
    public interface ChatServerPro extends ChatServerBasic
    {
        
    }
}
}}}

TODO

Another way to version interfaces is to not version the interfaces but version the package,<br>
as each package act as a context, you could switch from one context to another and keep the same<br>
type signatures for your interfaces.

{{{
package company.v1
{
    public interface ChatServer
    {
    
    }
}
}}}

{{{
package company.v2
{
    public interface ChatServer
    {
    
    }
}
}}}

TODO

Another example is gaforflash see [http://code.google.com/p/gaforflash/source/browse/#svn/trunk/src/com/google/analytics/v4 API v4]

in short, the *v4* package contains the configuration file, the API interface and 2 implementation of this interface

if the API had to evolve in a *v5* version, we would duplicate the same structure in a v5 package

the difference of versioned package is kind of hidden in the general interface [http://code.google.com/p/gaforflash/source/browse/trunk/src/com/google/analytics/AnalyticsTracker.as AnalyticsTracker]


TODO


== Annotation ==

==== 1 ====

[http://www.artima.com/lejava/articles/designprinciples.html Program to an interface, not an implementation]<br>
explained by Erich Gamma (you can not beat that :))

But here some comments as AS3 is not Java:

being able to switch implementation between a mock and the real implementation can be very usefull, and not only for testing

for example, at Miniclip, we use that to provide 2 implementations of our API based on the same interfaces<br>
when a game developer works localy in Flash IDE, he adds a gamemanager.swc and produce a game.swf<br>
there he is using a mock implementation of the API, the goal is to add the types/interfaces signature to the swf bytecode.<br>
Later, when the game.swf is loaded online by a gamemanager.swf, because our game manager is loaded first<br>
its implementation of the interfaces take priority in memory<br>
and so when the game.swf is loaded, any interfaces signature use those definition (as an application domain can not define twice the same implementation, see [ApplicationDomain] dirty secrets).

{{{
In Java when you add a new method to an interface, you break all your clients.
}}}

It does not work the same in AS3, from what I experienced you can add arguments to existing methods and add new methods and it will not break your clients, most of the time it will work.<br>
But in some cases I could not isolate, sometimes it could break, almost as if the bytecode was checking itself for differences, and if the differences are too big then the runtime will throw an error.

Also, don't try to emulate abstract in AS3, it will just fail, you don't have abstract classes in AS3<br>
it could change in a future AS4, but for now you have to do without it.

{{{
Another lesson learned is that you should focus not only on developing version one,
but to also think about the following versions.
This doesn't mean designing in future extensibility, but just keeping in mind that
you have to maintain what you produce and try to keep the API stable for a long time.
You want to build to last.
}}}

this is so true on so many levels for AS3 too.


==== 2 ====

[http://blog.iconara.net/2006/07/29/architectural-atrocities-part-5-interfaces-in-as3/ ARCHITECTURAL ATROCITIES, PART 5: INTERFACES IN AS3]