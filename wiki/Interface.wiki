#summary interfaces in AS3.
#labels Code,AS3

== Introduction ==

{{{
Interfaces provide a way for programs to express contracts between the producers and consumers of objects.
These contracts are type safe, easy to understand, and efficient to implement.
Programs should not have to pay a significant performance penalty for using interfaces.

An interface is a type whose methods must be defined by every class that claims to implement it.
Multiple interfaces can be inherited by another interface through the extends clause or by a class through the implements clause.
Instances of a class that implements an interface belong to the type represented by the interface.
Interface definitions must only contain function definitions, which may include get and set methods.

Interface methods are not public by default, but are added to the public namespace
by the implementing method definition.
}}}

see [http://livedocs.adobe.com/specs/actionscript/3/as3_specification95.html Interfaces (AS3 spec)]


== Details ==

Most of the time you will want to see an interface as a type, and based on that you would want to ditch the *I* in front of the name.

Yes, you don't need to put a capital *I* everywhere, and here some basic examples.

=== Basics use ===

Let's say that in your code you want a *Serializable* type<br>
so when you see an object that implement the interface you could say
{{{
my object is Serializable
}}}

what is the contract of a Serializable object ?
{{{
package
{

    public interface Serializable
    {
    
    }

}
}}}

with just that for every class implementing the interface you could test
{{{
trace( myobject is Serializable )
}}}

yes, you don't really need to define functions in this interface as your main concern is to be able to classify a type

Now if you want to enforce a contract, as
{{{
if you are of a type Serializable you have to respect a predefined behaviour
}}}

the definition of the contract will be the definition of the methods you add to an interface
{{{
package
{

    public interface Serializable
    {
        function toSource( indent:int = 0 ):String;
    }

}
}}}

eg.
  * you have to define a toSource method
  * this method have to return a string type
  * this method have one optional argument of type integer

that's the contract to respect to be considered of the *Serializable* type

=== Some Thoughts ===

When you're programming in a framework context you will want to use interfaces to define common behaviours,
here with maashaack we use *Serializable*, *Serializer*, etc.

Don't do that if you plan to have only one serializer, but do use interfaces if you want to define
a general serializer behaviour and have different implementation of it (a eden serializer, a WDDX serializer, a JSON serializer, etc.)

If you're programming in a public API context using interfaces is THE way to go,
you should even consider your interfaces being the API.<br>
Yes, even if you have only one implementation of the interface.<br>
You want the users of the public API to programm their code based on the interfaces, not the implementation.

But you should be aware of certain traps.

As soon as you put a public API out there, you can not change it.<br>
Well... you can not change the interfaces, but you can change the implementation.

Ok I lied a bit, you can change the interfaces, but you can not break them.<br>
And here come the biggest trap: how to version an API.

First, there are no rules and many many many ways of doing it.<br>
(I speak from my small experiences with Google Analytics and Miniclip, comments/critics welcome)

Here what may happen to your public API
  * on one side you gonna provide services to use publicly for your users
  * on the other side you'll have to update the implementation to correct bugs, add features, etc.

the best way imho to do that is to allow yourself to add but never remove anything.<br>
So your API can evolve, but not break older version or put another way: be backward compatible.

so here the basic rules for a public API (wether you have 100 or 10000 users)
  * always define interfaces for everything that your user can use (the public side)
  * never give access to the implementation (the private side)
  * never remove anything from your interfaces
  * use builtin types in your interfaces and/or other interfaces (don't use custom types)
  * be careful how you define your interfaces and how you add to it
  * if you want to give access to a single object (as an entry point), define an interface for it<br>and by extension use getter/setter to define properties for this object

for the versioning in itself I would favour versioning the implementations and keep the interfaces without versioning, but this can be done in a lot of different ways so this will highly depends on your needs (and your users needs).

=== Defining a public API ===

So for example sake,<br>
let's say we have a brand name *Kiki's delivery* which is also a website with some services<br>
and we want to provide access to those services via a public API.

Our use case is that *Kiki's delivery* is a gift delivery services and our main goal is to allow
any developers using our public API to deliver gifts by providing a gift number.

Here the plan:
  * we want *Kiki* to be an entry point
  * we want to provide a *services* interface
  * so at the end your user can do `Kiki.services.doSomething()`

let's define our interfaces
{{{
package kiki
{
    public interface KikiAPI
    {
        function get version():String;
        function get services():Services;
    }
}
}}}
{{{
package kiki
{
    public interface Services
    {
        function deliver( id:Number ):void;
    }
}
}}}

how your user will use it like that ?
{{{
var kiki:KikiAPI = new KikiAPIImplementation();
       kiki.services.deliver( 123 );
}}}

It's kind of bad as you have to give access to * KikiAPIImplementation* so the user can initialize your entry point.<br>
Also *KikiAPI* is not a very good name imho.

Here come the use of the [Singleton] to define your entry point and hide the implementation to your users.<br>
Let's rename *KikiAPI* to just *Kiki*
{{{
package kiki
{
    public interface Kiki
    {
        function get version():String;
        function get services():Services;
    }
}
}}}
then let's do an internal implementation of it
{{{
package kiki
{
    public class _Kiki implements Kiki
    {
        //...
    }
}
}}}
and finally provide an entry point for it
{{{
package kiki
{
    public const KikiDelivery:Kiki = new _Kiki();
}
}}}


now for your users, the use of the public API would be like that
{{{
import kiki.KikiDelivery;

KikiDelivery.services.deliver( 123 );
}}}

Very basic to implement and to use, and never your user need to know about your internal implementation.<br>
Tomorrow you can fix a dozen of bugs, you just keep the same interfaces and release a v1.1 update.

But after tomorrow your users are demanding and they ask to be able to deliver a gift with a card so they can put a friendly message on it.

Time to update your services interface
{{{
package kiki
{
    public interface Services
    {
        function deliver( id:Number, message:String = "" ):void;
    }
}
}}}

and your users can now use it
{{{
import kiki.KikiDelivery;

KikiDelivery.services.deliver( 123, "from russia with love" );
}}}

Even if the example is over-simplified, I hope you can still see where numerous problems can occurs
  * you could have a good half of your users not updating their app to the last API version
  * you have to deal in parallel with user using API v1.0 and user using API v2.0
  * if you don't give a default value for the message, you end up breaking old code that does not use the message property


so here *few tips* from various experiences:

*1.* always define a version of your API, but don't use the version number in the interface name

{{{
package kiki
{
    public class _Kiki implements Kiki
    {
        //...
        public function get version():String
        {
            return "1.0";
        }
    }
}
}}}

as a personal favorite I like to define an *API* class combined with an include file<br>
(you can reuse the include in an Ant build and use the rev number under SVN)
{{{
version.major = 1
version.minor = 0
version.build  = 0
}}}
{{{
package kiki
{
    public class API
    {
        public static var version:Version = new Version()
        include "version.properties"
        version.revision = "$Rev: 1234 $ ".split( " " )[1];
    }
}
}}}
and in your implementation
{{{
package kiki
{
    public class _Kiki implements Kiki
    {
        //...
        public function get version():String
        {
            return API.version.toString();
        }
    }
}
}}}

*2.* if you really have to use an object as an entry point for your API

Combine a Singleton and an Interface at the package level
and use a Factory to initialize this main object

small example
{{{
package kiki
{
    public class _Kiki implements Kiki
    {
        public function _Kiki()
        {
            _factory();
        }

        private function _factory():void
        {
             _services = new KikiServices();
        }

        public function get version():String
        {
            return API.version.toString();
        }

        public function get services():Services
        {
            return _services;
        }
    }
}
}}}

{{{
package kiki
{
    public const KikiDelivery:Kiki = new _Kiki();
}
}}}

This will work pretty well if your API does not interact with display objects,
also defining a constant at the package level will create your object pretty early in the stack.


*3.* if your main entry point object need a stage reference don't use a singleton at all

Directly provide the Factory to build the instance anywhere, something that will look like that
{{{
var myKiki:Kiki = new KikiDelivery( stage, any, other, options );
}}}

Notice the type, myKiki is the interface Kiki, not the class !KikiDelivery.

Sure it is less user friendly on the API side, but the way the display objects work if you really need
that stage reference you're kind of stuck.


*4.* know your users (or at least try)

There are various ways to distribute an API
  * simple SWC (code only)
  * source code templates
  * Flash Component (visual SWC)
  * Flex Component (visual SWC)
  * MXP
  * external SWF to load
  * etc.

and even more way your users will want to use this API, so for the little story,<br>
when we worked on the [http://code.google.com/p/gaforflash/ gaforflash] project we thought that the final users<br>
would want to either use either the Flash or Flex component and not use the *code only* version at all<br>
we made the code only version for us, as we prefer to deal with code directly,<br>
and it happen that a lot of people prefer the code only version.

For another little story on another project,<br>
we discovered that people wanted to drop a SWC in their Flash IDE library and have code completion in Flash<br>
and so to support that we had to create a small command line tool to parse the raw asdoc xml to generate Flash IDE xml documentation<br>
and by extension, the SWC was not enougth, we had to package all that in an MXP.
