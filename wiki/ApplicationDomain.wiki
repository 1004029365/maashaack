#summary ApplicationDomain dirty secrets.

== Introduction ==

The purpose of the !ApplicationDomain class is to store a table of ActionScript 3.0 definitions.<br>
All code in a SWF file is defined to exist in an application domain.<br>
You use application domains to partition classes that are in the same security domain.<br>
This allows multiple definitions of the same class to exist and also lets children reuse parent definitions.


== Details ==

Yep the dirty secrets stuff, ok not that secret but nowhere clearly explained by the Adobe doc.

=== Rules about !ApplicationDomain ===

Things to always keep in mind when dealing with appdom.

  # *An !ApplicationDomain is always dependant on a !SecurityDomain*
    * you have to *explicitly trust* another SWF to be able to access its appdom
    * the only way to connect two !SecurityDomain is to use *Direct Communication*
      a. *Import loading* using the `Loader` class<br>
      using `Loader.load()`
      {{{
var loader:Loader = new Loader();
var AD:ApplicationDomain = ApplicationDomain.currentDomain;
var SD:SecurityDomain    = SecurityDomain.currentDomain
var context:LoaderContext = new LoaderContext( false, AD, SD );
loader.load( new URLRequest( "other.swf" ), context );
      }}}
      using `Loader.loadBytes()`
      {{{
var loader:Loader = new Loader();
loader.loadBytes( new URLRequest( "other.swf" ) );
      }}}
      b. *Cross-Scripting* permissions via `Security.allowDomain()`
      {{{
The Security.allowDomain() method grant access for cross-scripting,
scripting the display list, access to the Stage object and event detection.
      }}}
      You can use `childAllowsParent` or `parentAllowsChild` properties of the `LoaderInfo` class<br>to know if two SWFs (a parent and a child) can cross-script.
  # *The root appdom is the system domain<br>which contains the builtins, Flash Player API classes, etc.*
    * the system domain have no parent [#1 |1|]
    * all other appdomain *always have a parent*
       
  # *The definition of `ApplicationDomain.currentDomain` is the appdom<br>that contains the code that is calling `ApplicationDomain.currentDomain`*
    * the `ApplicationDomain.currentDomain` is *unique to a SWF* [#2 |2|]
    * the `ApplicationDomain.currentDomain` is *unique to all loaded SWF*,<br>if `main.swf` load `child.swf` they both share the same `ApplicationDomain.currentDomain`
      
  # *If a definition already exists in a parent appdom,<br>the definition in the child is ignored*
    * you can not override a definition in anyway, period.<br>A child swf can not redefine/update/etc. a parent definition
    * a child appdom will *always* use the `static` or `const` definitions from the parent appdom
    * the only way a child appdom can use its own definitions (but without overriding the parent definition)<br>is to be loaded in isolation

=== Different !ApplicationDomains interaction ===

  # *Isolated !ApplicationDomain*<br>_new !ApplicationDomain( null )_
    {{{
var loader:Loader = new Loader();
var AD:ApplicationDomain = new ApplicationDomain( null );
var context:LoaderContext = new LoaderContext( false, AD );
loader.load( new URLRequest( "other.swf" ), context );
    }}}
  # *Child !ApplicationDomain*<br>_new !ApplicationDomain( !ApplicationDomain.currentDomain )_
    {{{
var loader:Loader = new Loader();
var AD:ApplicationDomain = new ApplicationDomain( ApplicationDomain.currentDomain );
var context:LoaderContext = new LoaderContext( false, AD );
loader.load( new URLRequest( "other.swf" ), context );
    }}}
  # *Imported !ApplicationDomain*<br>_!ApplicationDomain.currentDomain_
    {{{
var loader:Loader = new Loader();
var AD:ApplicationDomain = ApplicationDomain.currentDomain;
var context:LoaderContext = new LoaderContext( false, AD );
loader.load( new URLRequest( "other.swf" ), context );
    }}}



=== Special cases with AIR ===

AIR run on the desktop and because of that the appdom is even more touchy there.


== References ==

links

== Annotations ==

==== 1 ====
the Flash Player plugin contains the bytecode for the builtins class, yes it is embedded in the plugin hence why this system appdom can not have any parent.

==== 2 ====
here we're talking about the root SWF, meaning the first loaded SWF in the plugin, the _owner_.