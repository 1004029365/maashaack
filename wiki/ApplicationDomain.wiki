#summary ApplicationDomain dirty secrets.
#labels Code,AS3

== Introduction ==

The purpose of the !ApplicationDomain class is to store a table of !ActionScript 3.0 definitions.<br>
All code in a SWF file is defined to exist in an application domain.<br>
You use application domains to partition classes that are in the same security domain.<br>
This allows multiple definitions of the same class to exist and also lets children reuse parent definitions.


== Details ==

Yep the dirty secrets stuff, ok not that secret but nowhere clearly explained by the Adobe doc.

=== Rules about !ApplicationDomain ===

Things to always keep in mind when dealing with appdom.

  # *An !ApplicationDomain is always dependant on a !SecurityDomain*
    * you have to *explicitly trust* another SWF to be able to access its appdom
    * the only way to connect two !SecurityDomain is to use *Direct Communication*

    a) *Import loading* using the `Loader` class<br>
using `Loader.load()`
      {{{
var loader:Loader = new Loader();
var AD:ApplicationDomain = ApplicationDomain.currentDomain;
var SD:SecurityDomain    = SecurityDomain.currentDomain;
var context:LoaderContext = new LoaderContext( false, AD, SD );
loader.load( new URLRequest( "other.swf" ), context );
      }}}
      or using `Loader.loadBytes()`
      {{{
var raw:URLLoader = new URLLoader();
       raw.dataFormat = URLLoaderDataFormat.BINARY;
       raw.load( new URLRequest( "other.swf" )  );
var loader:Loader = new Loader();
loader.loadBytes( data );
      }}}
      here without `LoaderContext` you end up as a child appdomain<br>
be carefull here, by default a `loadBytes()` places the bytes in the current `SecurityDomain` but not necessary in the current `ApplicationDomain`, so you still have to use a `LoaderContext` to do a real *import loading* if you want to share the class definitions in memory!!<br>
so to do that
      {{{
var raw:URLLoader = new URLLoader();
       raw.dataFormat = URLLoaderDataFormat.BINARY;
       raw.load( new URLRequest( "other.swf" )  );
var AD:ApplicationDomain = ApplicationDomain.currentDomain;
var context:LoaderContext = new LoaderContext( false, AD );
var loader:Loader = new Loader();
loader.loadBytes( data, context );
      }}}
      here all is placed in the current appdomain and so you can share class definitions<br>
yes the difference is subtle but *very* important<br>
      b) *Cross-Scripting* permissions via `Security.allowDomain()`
      {{{
The Security.allowDomain() method grant access for cross-scripting,
scripting the display list, access to the Stage object and event detection.
      }}}
      You can use `childAllowsParent` or `parentAllowsChild` properties of the `LoaderInfo` class<br>to know if two SWFs (a parent and a child) can cross-script.
  # *The root appdom is the system domain<br>which contains the builtins, Flash Player API classes, etc.*
    * the system domain have no parent [#1 |1|]
    * all other appdomain *always have a parent*
  # *The definition of `ApplicationDomain.currentDomain` is the appdom<br>that contains the code that is calling `ApplicationDomain.currentDomain`*
    * the `ApplicationDomain.currentDomain` is *unique to a SWF* [#2 |2|]
    * the `ApplicationDomain.currentDomain` is *unique to all loaded SWF*,<br>if `main.swf` load `child.swf` they both share the same `ApplicationDomain.currentDomain`
  # *If a definition already exists in a parent appdom,<br>the definition in the child is ignored*
    * you can not override a definition in anyway, period.<br>A child swf can not redefine/update/etc. a parent definition
    * a child appdom will *always* use the `static` or `const` definitions from the parent appdom
    * the only way a child appdom can use its own definitions (but without overriding the parent definition)<br>is to be loaded in isolation

=== Different !ApplicationDomains interaction ===

  # *Isolated !ApplicationDomain*<br>_new !ApplicationDomain( null )_
    {{{
var loader:Loader = new Loader();
var AD:ApplicationDomain = new ApplicationDomain( null );
var context:LoaderContext = new LoaderContext( false, AD );
loader.load( new URLRequest( "other.swf" ), context );
    }}}
    * the parent appdom is the system domain
    * definitions in this appdom are *guaranteed to not collide* with other definitions
    * you *can not use those definitions in a strongly typed manner* in the parent appdom
    * you *can use those definitions as Objects (builtins)* using `getDefinition()` in the parent appdom
  # *Child !ApplicationDomain*<br>_new !ApplicationDomain( !ApplicationDomain.currentDomain )_
    {{{
var loader:Loader = new Loader();
var AD:ApplicationDomain = new ApplicationDomain( ApplicationDomain.currentDomain );
var context:LoaderContext = new LoaderContext( false, AD );
loader.load( new URLRequest( "other.swf" ), context );
    }}}
    * the parent appdom is the !ApplicationDomain.currentDomain
    * definitions in this appdom are added to the parent appdomain if not already defined
    * you *can use those definitions in a strongly typed manner* in the parent appdom
    * this child appdom *can not access definitions from the parent appdom* by default
      {{{
If the loading SWF [parent] has classes that should not be immediately exposed to loaded SWF files [childs],
then the developer should load the SWF as a child of the system's ApplicationDomain
to ensure it [child] does not inherit the loading SWF [parent] file's classes.
      }}}
    * you *can load definitions as strong types* using `getDefinition()` from other appdom
      {{{
However, in this usage, the child SWF file may still be able to explicitly retrieve
definitions from other ApplicationDomain if it knows their location.
      }}}
  # *Imported !ApplicationDomain*<br>_!ApplicationDomain.currentDomain_
    {{{
var loader:Loader = new Loader();
var AD:ApplicationDomain = ApplicationDomain.currentDomain;
var context:LoaderContext = new LoaderContext( false, AD );
loader.load( new URLRequest( "other.swf" ), context );
    }}}
    * the parent appdom is the system domain
    * definitions in this appdom *are imported into the !ApplicationDomain.currentDomain* (hence the name _import loading_)
    * you have to *load this appdomain before any ABC calls/uses any of its definitions*[#3 |3|]
    * two identical definitions will conflict, you can not declare twice the class `FooBar` for ex[#4 |4|]


=== Special case with AIR ===

AIR run on the desktop and because of that the appdom is even more touchy there.

Remember the first rule that an appdomain is always dependent on a !SecurityDomain,
so when come the time where a desktop AIR application want to load a remote SWF,
you obtain a security clash between a local !SecurityDomain and a remote !SecurityDomain.

This is by default in AIR and this is normal and wanted, you would not want to give I/O access or
full control to a remotely downloaded SWF by default do you ?

But if you have to or need to here how to do an import loading in AIR<br>
(consider that as pseudo-code)
{{{
var urlloader:URLLoader = new URLLoader();
       urlloader.dataFromat = URLLoaderDataFormat.BINARY;
       urlloader.addEventListener( Event.COMPLETE, onComplete );
       urlloader.load( new URLRequest( "other.swf" ) );

var onComplete:Function = function( event:Event ):void
{
    var loader:Loader = new Loader();
    var AD:ApplicationDomain = ApplicationDomain.currentDomain;
    //with loadBytes(0 -- the checkPolicyFile and securityDomain properties of the LoaderContext object do not apply.
    //var SD:SecurityDomain    = SecurityDomain.currentDomain;
    var context:LoaderContext = new LoaderContext( false, AD );
           context.allowLoadBytesCodeExecution = true;

    loader.loadBytes( urlloader.data, context );
}
}}}

{{{
If the context parameter is not specified or refers to a null object, the content is loaded into the current security domain
â€” a process referred to as "import loading" in Flash Player security documentation. Specifically, if the loading SWF file
trusts the remote SWF by incorporating the remote SWF into its code, then the loading SWF can import it directly into its own security domain.
}}}

The cool thing is once you have the SWF loaded with `URLLoader`
you can decide to apply different appdomain interactions with `Loader`,
either isolated or child or imported.

The bad thing is because the AIR API is defined at the system appdomain level,
this remotely loaded SWF can use any AIR functionalities like reading from your hard drive,
and you can not prevent that even if you put the appdom in isolation
(it will isolate the loaded swf from calling your code that's all).

So you should be very very very sure that this remote SWF you are loading is damn secure!!

== References ==

  * [http://livedocs.adobe.com/flash/9.0/main/wwhelp/wwhimpl/common/html/wwhelp.htm?context=LiveDocs_Parts&file=00000327.html Adobe - Using the ApplicationDomain class]
  * [http://blogs.adobe.com/rgonzalez/2006/06/applicationdomain.html Roger Gonzalez - ApplicationDomain]
  * [http://www.adobe.com/devnet/flashplayer/articles/secure_swf_apps_07.html Creating more secure SWF web applications - Communicating Between SWFs and across Domains]
  * [http://jvalentino.blogspot.com/2009/06/flex-memory-issue-4-modules-and.html Flex Memory Issue #4: Modules and Application Domains]
  * [http://weblogs.macromedia.com/emalasky/archives/2008/04/remote_plugins.html Remote Plugins and Modules in AIR]
  * [http://code.google.com/p/doctype/wiki/ArticleFlashSecuritySolutions doctype - HOWTO secure your Flash applications]

== Annotations ==

==== 1 ====
the Flash Player plugin contains the bytecode for the builtins class, yes it is embedded in the plugin hence why this system appdom can not have any parent.

==== 2 ====
here we're talking about the root SWF, meaning the first loaded SWF in the plugin, the _owner_.

==== 3 ====
ABC = !ActionScript !ByteCode, contains the definition as binary form.

==== 4 ====
this also explain why you can not override or redefine a builtin class, first because its definition is in the parent appdom, but even if you were able to load your own definition in the system appdom it will collide with the already existing definition.