#summary framework overview.

== Introduction ==

The maashaack project provide different stuff.

The *maashaack application framework*<br>
is a set of different modular projects assembled together<br>
to produce a coherent set of AS3 classes, packages and libraries<br>
which represent our ideal of "programming in the large".

The *maashaack projects*<br>
are independent modules which focus on one particular set of problem,<br>
they fit the need of "programming in the small".

The *maashaack tools*<br>
are executable tools in relation with the AS3 language and/or the Flash Platform<br>
their goal is to cover small area not covered by much bigger tools (like the Flex SDK).

The *maashaack documentation*<br>
focus mainly on the use of the different frameworks, classes, libraries, etc.<br>
but also try to assemble the best ressources related to AS3 and Flash development in general.

TODO

== Packages ==

see [Packages].


=== core ===

The core root package is specialized in classes and functions utilities that are highly reusable without creating any dependencies.

You can consider a library as a set of functions organized into classes,<br>
here with a "core" library in some cases we organize the functions<br>
in the package definitions without assembling them into a class.

ideally you would want to write it like that
{{{
package core
{
    public function test( message:String ):void
    {
        trace( message );
    }
}
}}}

but there is a subtle bug in Flash CS3 that would prevent users to use<br>
a function declared at the package level from a SWC, so instead of a declaring<br>
a function, we declare a variable of the type `Function`.

{{{
package core
{
    public var test:Function = function( message:String ):void
    {
        trace( message );
    }
}
}}}

but wait, we want speeeeeed so we make that a constant
{{{
package core
{
    public const test:Function = function( message:String ):void
    {
        trace( message );
    }
}
}}}

We'll try to come up with speed comparison, but here what we assume
 * a package-level function is slightly faster than a static function call
 * a function marked as final is faster (avoid the compiler to do runtimes lookup)
 * a package-level constant should be as fast or even faster than a package-level function


Also in most of the code editors (even Flex Builder), when you make a reference to<br>
a variable declared at the package level, the `import` can be cleaned up<br>
here a way to force the import to stay, use `void(function)`
{{{
package
{
    import core.strings.format; void(format);
    
    import flash.display.Sprite;
    
    public class Main extends Sprite
    {
        //...
    }
}
}}}

Those functions are allowed to reuse the builtin types (Object, Array, etc.),<br>
the Flash API classes and packages, but nothing else.

Here some basic rules:
 * nothing declared in the unnamed package (eg. `package { ... }`)
 * all functions or classes start with a lowercase letter (use `bit`, not `Bit`)
 * try to reuse similar name for similar functionality (`core.strings.compare` and `core.arrays.compare`)
 * you can not reuse another function or class from any other maashaack package, even from core itself
 * you can not reuse a third party library at all
 * no use of interfaces, enums, events, namespaces, etc.
 * everything have to be "inlined code"
 * the code have to be written for speed and less use of memory
 * it have to work everywhere (redtamarin included)

You really have to see what's in *core* as building blocks to build bigger classes.

Why we impose all those rules ?
 * even if you include *core.swc* in your libraries<br>the final bytecode injected in your final swf will be minimal
 * core will not create strong dependencies of any sort in your code
 * at the very worst, you can extract the code of a function and inline it directly in your code


TODO

=== system ===

The system root package is the starting point of the application framework structure,<br>
dependencies are allowed but strictly controlled.

Definitions in *system* are allowed to reuse the builtin types (Object, Array, etc.),<br>
the Flash API classes and packages, and other system libraries.

Here some basic rules:
 * nothing declared in the unnamed package (eg. `package { ... }`)
 * classes starts with an uppercase letter and use !CamelCase
 * namespaces starts with a lowercase letter
 * conditional compilation are always in uppercase letters (see ConditionalCompilation)
 * interfaces follow classes naming convention and are considered types<br>no interfaces starting with *I* (define `Serializable`, not `ISerializable`)
 * `System.*` root package define commons types, classes, interfaces, namespaces etc.<br>that can be shared and reused in sub-packages
 * each sub-package should be independent of another sub-package but can have dependencies on the root package<br> in `System.terminals.*` you can reuse `System.Serializable` but not `System.diagnostics.Debuggable`
 * there can be some exceptions with highly used packages like `System.data.*`<br>`System.process.*` can reuse classes and interfaces from `System.data.*`<br>but the root package `System.*` will avoid to reuse `System.data.*`
 * you can not reuse a third party library at all
 * ...

You need to see *system* as a dual structure<br>
on one side you have the idea of generating the *maashaack.swc* library (contain everything)<br>
and on the other side you want to generates independent slices of the framework<br>
like: *system.swc*, *system.data.swc*, *system.terminals.swc*, etc.

It is really hard and require a constant discipline to provide this level of controlled dependency<br>
between packages but it is really for the greater good :).

We don't want a single `import` of a class to add tons of other classes and interfaces,
but we can accept to say "if you want to use `system.process` you have to include *system.swc* and *system.data.swc*".

At the end of the day, if we can not generate independent swc for each packages,<br>
and we have to resort on using only *maashaack.swc*, we fail.

Why we impose all those rules ?
 * we need to control the amount of bytecode ending in the final swf<br>see the Flex framework, you include one component and you end up with ~250KB of code<br>we want to avoid that
 * we want to be able to have common reusable areas and interchangeable areas<br>wether you want to use an optimized set of classes for flash player 10 (using `Vector` instead of `Array`)<br>or switch between different implementations of "signals and slots"
 * we want to be able to manage sub-packages as modules<br>creating, adding, removing, etc. a module should not influence other modules (or break things)
 * we want to be able to kick start a project or new sub-package over a week-end<br>when you face too much dependencies spread in every corners you can not do that


*use case:* assemble different functions in a string utility class
{{{
package com.foobar.utils
{
    import core.strings.fastformat; void(fastformat);
    import core.strings.format; void(format);
    import core.strings.pad; void(pad);
    
    public class Strings
    {
        
        CONFIG::LIGHT
        public static var format:Function = core.strings.fastformat;
        
        CONFIG::STANDARD
        public static var format:Function = core.strings.format;
        
        public static function padLeft( str:String, amount:uint, char:String = " " ):String
        {
            return pad( str, -int(amount), char );
        }
        
        public static function padRight( str:String, amount:uint, char:String = " " ):String
        {
            return pad( str, int(amount), char );
        }
        
    }
}
}}}
here we reuse the building blocks of *core* to build *system.Strings*<br>
you can see, for example, ConditionalCompilation settings that allow to switch the<br>
same function *format* between 2 implementations


TODO

=== graphics ===

The graphics root package is to be considered as an addon to *system*,<br>
mostly related to the highly graphic nature of the Flash Platform.

Definitions in *graphics* are allowed to reuse the builtin types (Object, Array, etc.),<br>
the Flash API classes and packages, and other system libraries.

TODO

== Library ==

The library root package is an effort to organize and standardize<br>
external and independent code libraries that can be added to *system* on a needed basis<br>
without necessary being part of the application framework.

For example `library.zlib.*` would be a sub-package implementing in AS3<br>
the C/C++ zlib library that can be found here [http://www.zlib.net www.zlib.net].

Another example would be `library.PNG` which could take some base code from<br>
other open source projects and/or from the [http://www.w3.org/TR/PNG/ PNG specification]<br>
and/or port a library from another language and/or implements the library with [http://labs.adobe.com/technologies/alchemy/ Alchemy].

TODO

== Platform ==

Platform libraries are low level libraries, and mostly related to the [http://www.mozilla.org/projects/tamarin/ Tamarin project] or [http://code.google.com/p/redtamarin/ redtamarin].

For example `C.stdlib.*` would be subpackage defining native AS3 classes or functions<br>
to their implementation in C/C++ (defined in redtamarin)

Another example would be `flash.*` implementing in AS3 the Flash Player native classes (found in *playerglobal.swc*)<br>
either used as mock with redtamarin, or as native AS3 classes and implemented in C/C++ to a certain levels to be used on the command line.


== Tools ==

The tools are not considered as part of a package structure,<br>
they are mainly the organization of small applications<br>
that focus on AS3 and Flash development.

For example `abcdump.exe` could be a little command-line tool<br>
based on `abcdump.as` found in the Tamarin project.

Another example would be to take `flvtool2` written in Ruby and port it to AS3.

Here the goal is to create needed tool and/or improve existing tools,<br>
but also manage and maintain their build process and distribution.

*use case:* abcdump<br>
For a basic user, being able to build `abcdump.exe` for Windows<br>
could be a big task: install and learn to use Visual Studio, learn to use mercurial,<br>
learn how to compile Tamarin, learn how to compile an abc file,<br>
learn how to compile a running exectubale with avmshell and and abc file, etc.

For us, the task would be to create a small project to isolate the necessary source code,<br>
organize the build so a Windows, OS X and Linux command line executable could be generated<br>
document its usage and distribute it.


TODO