#summary framework overview.

== Introduction ==

The maashaack project provide different stuff.

The *maashaack application framework*<br>
is a set of different modular projects assembled together<br>
to produce a coherent set of AS3 classes, packages and libraries<br>
which represent our ideal of "programming in the large".

The *maashaack projects*<br>
are independent modules which focus on one particular set of problem,<br>
they fit the need of "programming in the small".

The *maashaack tools*<br>
are executable tools in relation with the AS3 language and/or the Flash Platform<br>
their goal is to cover small area not covered by much bigger tools (like the Flex SDK).

The *maashaack documentation*<br>
focus mainly on the use of the different frameworks, classes, libraries, etc.<br>
but also try to assemble the best ressources related to AS3 and Flash development in general.

TODO

== Packages ==

We do not believe the classic `com/org/net + company name + product name`<br>
apply to a general framework naming system.

=== core ===

The core package is specialized in classes and functions utilities that are highly reusable without creating any dependencies.

here an example
{{{
package core
{
    public var test:Function = function( message:String ):void
    {
        trace( message );
    }
}
}}}

ideally we would want to write it like that
{{{
package core
{
    public function test( message:String ):void
    {
        trace( message );
    }
}
}}}

but there is a subtle bug in Flash CS3 that would prevent users to use<br>
a function declared at the package level from a SWC, so instead of a declaring<br>
a function, we declare a variable of the type `Function`.

Also in most of the code editors (even Flex Builder), when you make a reference to<br>
a variable declared at the package level, the `import` can be cleaned up<br>
here a way to force the import to stay, use `void(function)`
{{{
package
{
    import core.strings.format; void(format);
    
    import flash.display.Sprite;
    
    public class Main extends Sprite
    {
        //...
    }
}
}}}

Those functions are allowed to reuse the builtin types (Object, Array, etc.),<br>
the Flash API classes and packages, but nothing else.

Here some basic rules:
 * nothing declared in the unnamed package (eg. `package { ... }`)
 * all functions or classes start with a lowercase letter (use `bit`, not `Bit`)
 * try to reuse similar name for similar functionality (`core.strings.compare` and `core.arrays.compare`)
 * you can not reuse another function or class from any other maashaack package, even from core itself
 * you can not reuse a third party library at all
 * no use of interfaces, enums, events, namespaces, etc.
 * everything have to be "inlined code"
 * the code have to be written for speed and less use of memory
 * it have to work everywhere (redtamarin included)

You really have to see what's in *core* as building blocks to build bigger classes.

Why we impose all those rules ?
 * even if you include *core.swc* in your libraries<br>the final bytecode injected in your final swf will be minimal
 * core will not create strong dependencies of any sort in your code
 * at the very worst, you can extract the code of a function and inline it directly in your code


TODO

=== system ===

The system package is the root of the application framework structure,<br>
dependencies are allowed but strictly controlled.

Definitions in *system* are allowed to reuse the builtin types (Object, Array, etc.),<br>
the Flash API classes and packages, and other system libraries.

Here some basic rules:
 * nothing declared in the unnamed package (eg. `package { ... }`)
 * classes starts with an uppercase letter and use !CamelCase
 * namespaces starts with a lowercase letter
 * interfaces follow classes naming convention and are considered types<br>no interfaces starting with *I* (define `Serializable`, not `ISerializable`)
 * `System.*` root package define commons types, classes, interfaces, namespaces etc.<br>that can be shared and reused in sub-packages
 * each sub-package should be independent of another sub-package but can have dependencies on the root package<br> in `System.terminals.*` you can reuse `System.Serializable` but not `System.diagnostics.Debuggable`
 * there can be some exceptions with highly used packages like `System.data.*`<br>`System.process.*` can reuse classes and interfaces from `System.data.*`<br>but the root package `System.*` will avoid to reuse `System.data.*`
 * you can not reuse a third party library at all
 * ...

You need to see *system* as a dual structure<br>
on one side you have the idea of generating the *maashaack.swc* library (contain everything)<br>
and on the other side you want to generates independent slices of the framework<br>
like: *system.swc*, *system.data.swc*, *system.terminals.swc*, etc.

It is really hard and require a constant discipline to provide this level of controlled dependency<br>
between packages but it is really for the greater good :).

We don't want a single `import` of a class to add tons of other classes and interfaces,
but we can accept to say "if you want to use `system.process` you have to include *system.swc* and *system.data.swc*".

At the end of the day, if we can not generate independent swc for each packages,<br>
and we have to resort on using only *maashaack.swc*, we fail.


*use case:* assemble different functions in a string utility class
{{{
package com.foobar.utils
{
    import core.strings.fastformat; void(fastformat);
    import core.strings.format; void(format);
    import core.strings.pad; void(pad);
    
    public class Strings
    {
        
        CONFIG::LIGHT
        public static var format:Function = core.strings.fastformat;
        
        CONFIG::STANDARD
        public static var format:Function = core.strings.format;
        
        public static function padLeft( str:String, amount:uint, char:String = " " ):String
        {
            return pad( str, -int(amount), char );
        }
        
        public static function padRight( str:String, amount:uint, char:String = " " ):String
        {
            return pad( str, int(amount), char );
        }
        
    }
}
}}}
here we reuse the building blocks of *core* to build *system.Strings*<br>
you can see, for example, ConditionalCompilation settings that allow to switch the<br>
same function *format* between 2 implementations


TODO

=== graphics ===

TODO

== Libraries ==

TODO

== Tools ==

TODO