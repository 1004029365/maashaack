#summary One-sentence summary of this page.
#labels Documentation,Framework

= Command and Task Engine =

== Introduction ==

The *process engine* provides general abstraction to create and manage asynchronous operations in your applications. It is include in the package *system.process*. 

In the life cycle of the applications it's important to create custom and specific tasks and to use tools who allow to grouping them for concurrent or sequential execution :
 * loading external configuration files, 
 * loading external swfs or modules, 
 * loading pictures or sounds or animations, 
 * invoking remote services, 
 * invoking motion tween, 
 * controlling the time-line of your MovieClip, 
 * creating a pause, 
 * and more...

While each of these operations are quite easy to handle on their own, it can soon become quite complex if you have to combine lots of these operations. 

== Interfaces ==

The *system.process* package contains important interfaces to create your custom task : 
*Runnable, Lockable, Priority, Action, Startable, Stoppable, Resumable* and *Resetable.*

=== The Runnable interface ===

The *process engine* is based on the *Design Pattern Command*. A design pattern in which an object is used to represent and encapsulate all the informations needed to execute a method or task at a later time.

Using command objects makes it easier to construct general components that need to delegate, sequence or execute method calls at a time of their choosing without the need to know the owner of the method or the method parameters.

The *system.process.Runnable* interface defines the basic implementation to create a command.

{{{
package system.process
{
    public interface Runnable
    {
        function run( ...arguments:Array ):void ;
    }
}
}}}

The *run* method is the launcher of the command and all class who implements the *Runnable* interface must contains this method.

For example we can create a *Move* command to change the position of a specific display in your application.

{{{
package examples.process
{
    import flash.display.DisplayObject ;
    import system.process.Runnable ;
	
    public class Move implements Runnable
    {
        public function Move( target:DisplayObject , x:Number , y:Number )
        {
            this.target = target ;
            this.x      = x ;
            this.y      = y ;
        }
     
        public var target:DisplayObject ;

        public var x:Number ;
        
        public var y:Number ;
	    
        public function run( ...arguments:Array ):void
        {
            if( arguments.length > 0 )
            {
                this.x = arguments[0] as Number ;
                this.y = arguments[1] as Number ;
            }
            if( target )
            {
                target.x = x ;
                target.y = y ;
            }
        }
    }
}
}}}

We can executes this command at a time of our choosing :

{{{
package examples
{
    import examples.process.Move;

    import system.process.Runnable;

    import flash.display.Shape;
    import flash.display.Sprite;
    import flash.utils.setTimeout;
  
    public class RunnableExample extends Sprite
    {
	  public function RunnableExample()
        {
            ////// Creates the shape
          
            var shape:Shape = new Shape() ;
          
            shape.x = 25 ;
            shape.y = 25 ;
          
            shape.graphics.beginFill( 0xFF0000 ) ;
            shape.graphics.drawRect( 0 , 0 , 40 , 40 ) ;
          
            addChild( shape ) ;
            
            ////// Creates the command
            
            var command:Runnable = new Move( shape , 250 , 160 ) ;
            
            ////// Execute the command in two seconds
                      
            setTimeout( command.run , 2000 ) ;
        }
    }
}
}}}

=== The Lockable interface ===

The *system.process.Lockable* interface provide more extensive locking operations. This interface defines three important methods : *lock*(), *unlock*() and *isLocked*().

{{{
package system.process
{
    public interface Lockable
    {
        function isLocked():Boolean ;

        function lock():void ;

        function unlock():void ;
    }
}
}}}

This minimalist interface can be implemented by any class that requires in there life cycle many updates and many repetitive actions that could affect the performance by lowering all the application. We can use this interface too to lock event propagation for example.

*Example :*

Consider a class to defines a basic component that has multiple virtual properties (get/set). This component uses this properties to update this color, this size, etc.. When the user initialize all properties of the component after running modified each time a method to update the component.

To illustrate this concept I will create a visual class *examples.display.RectangleSprite* which lets you create dynamic graphics rectangular symbols, this class implements the interface Lockable.

{{{
package examples.display
{
    import flash.display.Sprite;
    
    import system.process.Lockable;  
    
    /**
     * This sprite draw a rectangle with a virtual width and height value.
     */
    public class RectangleSprite extends Sprite implements Lockable
    {
        /**
         * Creates a new RectangleSprite instance.
         */
        public function RectangleSprite()
        {
            super() ;
        }
        
        /**
         * The color of the rectangle shape.
         */
        public function get color():uint
        {
            return _color ;
        }      
        
        /**
         * @private
         */
        public function set color( value:uint ):void
        {
            _color = value ;
            update() ;
        }       
        
        /**
         * Determinates the virtual height value of this sprite.
         */
        public function get h():Number
        {
            return _h ;
        }
        
	/**
         * @private
         */
        public function set h( n:Number ):void
        {
            _h = isNaN(n) ? 0 : n ;
            update() ;
        }      
        
        /**
         * Determinates the virtual height value of this sprite.
         */
        public function get w():Number
        {
            return _w ;
        }
     
	  /**
         * @private
         */
        public function set w( n:Number ):void
        {
            _w = isNaN(n) ? 0 : n ;
            update() ;
        }          
     
        /**
         * Draw the display.  
         */
        public function draw():void
        {
            graphics.clear() ;
            graphics.beginFill( color , 1 ) ;
            graphics.drawRect( 0, 0, w, h ) ;
        }      
     
        /**
         * Returns true if the object is locked.
         * @return true if the object is locked.
         */
        public function isLocked():Boolean
        {
            return ___isLock___ == true ;
        }
     
        /**
         * Locks the object.
         */
        public function lock():void
        {
            ___isLock___ = true ;
        }
     
        /**
         * Unlocks the object.
         */
        public function unlock():void
        {
            ___isLock___ = false ;
        }
     
        /**
         * Update the display.
         */
        public function update():void
        {
            if ( isLocked() )
            {
                return ;
            }
            trace( this + " update" ) ;
            draw() ;
        }

        /**
         * @private
         */
        protected var _color:uint = 0xFF0000 ;      
     
        /**
         * @private
         */
	  protected var _h:Number = 0 ;
     
        /**
         * @private
         */
	  protected var _w:Number = 0 ;
     
        /**
         * The internal flag to indicates if the display is locked or not.
         * @private
         */
        private var ___isLock___:Boolean ;      
    }
}
}}}

The class examples.display.RectangleSprite defines the virtual properties color, h and w. This properties defines the color, the height and the width components to draw the dynamic shape. Each call to one of these properties will automatically start the *update*() method to refresh the view with the draw() method defined in the class.

The *RectangleSprite* class implement the *Lockable* interface and use only a little *Boolean* flag to switch between the locked and unlocked mode with the *isLocked*() method in the *update*() method :

{{{
/**
 * Update the display.
 */
public function update():void
{
   if ( isLocked() )
   {
       return ; // breakpoint
   }
   trace( this + " update" ) ;
   draw() ;
}
}}}

This break point with a return statement will be invoked if the method *isLocked*() returns true. This simple method can be deployed in any class.

Let's now a little bit of ActionScript code to illustrate this example :

{{{
import examples.display.RectangleSprite ;

var sprite:RectangleSprite = new RectangleSprite() ;

sprite.color = 0xFF00FF
sprite.w     = 200 ;
sprite.h     = 180 ;

sprite.x     = 25 ;
sprite.y     = 25 ;

addChild( sprite ) ;
}}}

Now we can run the compiled application, I get a rectangle on the stage and in the output panel we can read the following message :

{{{
[object RectangleSprite] update
[object RectangleSprite] update
[object RectangleSprite] update
}}}

The *update*() method is called three times when we defines the properties w, h and color.

In a small piece of code like this notion of optimization is not very important, but on a larger scale if we try to instantiate multiple objects we observe countless unnecessary calls the *update*() method.

Now, we can rewrite the example with the *Lockable* hack.

{{{
import examples.display.RectangleSprite ;

var sprite:RectangleSprite = new RectangleSprite() ;

sprite.lock() ;

sprite.color = 0xFF00FF
sprite.w     = 200 ;
sprite.h     = 180 ;

sprite.unlock() ;

sprite.update() ;

sprite.x     = 25 ;
sprite.y     = 25 ;

addChild( sprite ) ;
}}}

In the output of the flashplayer we can read the following message :

{{{
[object RectangleSprite] update
}}}

The *update*() method is called only once after the *unlock*() method to update the view of the display.

*Note* : In *AS3* we can find the *lock*() and *unlock*() method in some native class like *flash.display.BitmapData* but this class don't implements the *Lockable* interface.

=== The Priority interface ===

The *system.process.Priority* interface is providing the priority of a specific task who implements this interface in the application.

{{{
package system.process 
{
    public interface Priority 
    {
        function get priority():int ;
        function set priority( value:int ):void ;
    }
}
}}}

The *priority* property defines the value of the priority. The priority member can be used to sort tasks in chains, batch, priority queues, etc.

=== The Action interface ===


The *system.process.Action* interface provide a complete task implementation in the *system.process* package.

{{{
package system.process 
{
    import system.Cloneable;
    import system.signals.Signaler;
    
    /**
     * This interface represents the methods implemented in the Action objects.
     */
    public interface Action extends Cloneable, Runnable
    {
        /**
         * This signal emit when the notifyFinished method is invoked. 
         */
        function get finishIt():Signaler ;
        function set finishIt( signal:Signaler ):void ;
        
        /**
         * The current phase of the action.
         * @see system.process.TaskPhase
         */
        function get phase():String ;
        
        /**
         * Indicates <code class="prettyprint">true</code> if the action is in progress.
         */
        function get running():Boolean ;
        
        /**
         * This signal emit when the notifyStarted method is invoked. 
         */
        function get startIt():Signaler ;
        function set startIt( signal:Signaler ):void ;
        
        /**
         * Notify when the process is finished.
         */
        function notifyFinished():void ;
        
        /**
         * Notify when the process is started.
         */
        function notifyStarted():void ;
    }
}
}}}

The *Action* interface defines a command with a beginning and an ending. All tasks are based on this interface implementation.

The *Action* interface provide objects who use signals propagation with the *system.signals* engine to notify the start and the finish of the process.

All the task who implements the *Action* interface must contains two signals finishIt and startIt to connect slots (receivers).

*Example with signals and receivers :*

{{{
import system.process.Action ;

var finish:Function = function( action:Action ):void
{
    trace( "finish" ) ;
}

var start:Function = function( action:Action ):void
{
    trace( "start" ) ;
}

action.startIt.connect( start ) ;
action.finishIt.connect( finish ) ;
}}}

The *notifyFinished()* and *notifyStarted()* methods are invoked in the tasks to notify the beginning and the ending of the task process. 

The running property is a boolean who indicates if the process is in progress.

The *phase* property is a specific value to indicates the current phase of the process, we can defines all phases of the process with the static enumeration *system.process.TaskPhase* :

{{{
package system.process 
{
    /**
     * The enumeration of all phases in a task process.
     */
    public class TaskPhase 
    {
        /**
         * The phase of a delayed task.
         */
        public static const DELAYED:String = "delayed" ;
        
        /**
         * The phase of a finished task.
         */
        public static const FINISHED:String = "finished" ;
        
        /**
         * The phase before the task has been started for the first time or (for restartable Tasks) also after it has completed its execution.
         */
        public static const INACTIVE:String = "inactive" ;
        
        /**
         * The phase of a running Task.
         */
        public static const RUNNING:String = "running" ;
        
        /**
         * The phase of a finished task.
         */
        public static const STOPPED:String = "stopped" ;
        
        /**
         * The phase of an out of time task.
         */
        public static const TIMEOUT:String = "timeout" ;
    }
}
}}}

All Action objects are *Cloneable*, we can creates a shallow copy of a specific task with the *clone()* method.

The basic implementation of the *Action* interface is the *system.process.Task* class, 100% of all *Action* in your application must inherit the *Task* class or you must be sure to implement the interface with the same code in your custom class.

=== The Startable, Stoppable, Resetable and Resumable interfaces ===

The *system.process.Startable* interface is used when tasks need to be "running" to be active. It provides a method through which task can be "started".
{{{
package system.process
{
    public interface Startable
    {
        function start():void ;
    }
}
}}}

The *system.process.Stoppable* interface is used when tasks need to be inactive. It provides a method through which task can be "stopped".
{{{
package system.process
{
    public interface Stoppable
    {
        function stop():void ;
    }
}
}}}

The *system.process.Resetable* interface is used when tasks need to be reset.
{{{
package system.process
{
    public interface Resetable
    {
        function reset():void ;
    }
}
}}}

The *system.process.Resumable* interface is used when tasks need to be resume.
{{{
package system.process
{
    public interface Resumable
    {
        function resume():void ;
    }
}
}}}

All this basic interfaces are important to create complex tasks in your application. 

For example in a *Chain* who is running, the user may be forced to stop the execution of the main process and the current task in the chain who implement the *Stoppable* interface can be stopped too.

Now if the user want resume the *Chain* main process, the current task can be resumed too if it's implement the *Resumable* interface. 

This interfaces may seem simplistic but it can easily handle many tasks in a specific context of your applications.

== Basic Runnable implementations ==

=== The system.process.Batch class ===

Batch processing is execution of a series of tasks in your application. A batch process can be used to automate much of the work.

A batch process performs an asynchronous list of commands and run it a single stroke.

Example, we create a little *Square* display class who implements the *Runnable* interface, the run method of this class invoke an "enterframe" event process to move the display to a specific position.

{{{
package examples.display
{
    import system.process.Runnable;
    
    import flash.display.Sprite;
    import flash.events.Event;
    import flash.filters.DropShadowFilter;
    import flash.geom.Point;
    
    public class Square extends Sprite implements Runnable
    {
        public function Square( x:int=0, y:int=0, color:uint=0xFFFFFF )
        {
            this.x = x ;
            this.y = y ;
            graphics.beginFill( color ) ;
            graphics.drawRect(0, 0, 30, 30) ;
        }
        
        public var finish:Point ;
        
        public function run(...arguments:Array):void
        {
            if ( finish )
            {
                addEventListener(Event.ENTER_FRAME , enterFrame ) ;
            }
        }
        
        protected function enterFrame( e:Event ):void
        {
            var dx:Number = Math.round( ( finish.x - x ) * 0.3 ) ;
            var dy:Number = Math.round( ( finish.y - y ) * 0.3 ) ;
            x += dx ;
            y += dy ;
            if ( dx == 0 && dy == 0 )
            {
                removeEventListener(Event.ENTER_FRAME , enterFrame ) ;
            }
        }
    }
}
}}}

Now we can use this basic command/display objects in a batch :

{{{
package examples
{
    import examples.display.Square;
    
    import system.process.Batch;
    
    import flash.display.Sprite;
    import flash.events.KeyboardEvent;
    import flash.geom.Point;
    
    [SWF(width="740", height="480", frameRate="24", backgroundColor="#666666")]
    
    public class BatchExample extends Sprite
    {
        public function BatchExample()
        {
            var s1:Square = new Square( 50 ,  50 , 0xFF0000 ) ;
            var s2:Square = new Square( 50 , 100 , 0x00FF00 ) ;
            var s3:Square = new Square( 50 , 150 , 0x0000FF ) ;
            
            s1.finish = new Point( 600 ,  50 ) ;
            s2.finish = new Point( 600 , 100 ) ;
            s3.finish = new Point( 600 , 150 ) ;
            
            addChild(s1) ;
            addChild(s2) ;
            addChild(s3) ;
            
            command = new Batch() ;
            command.add( s1 ) ;
            command.add( s2 ) ;
            command.add( s3 ) ;
            
            // press a key to run the batch
            
            stage.addEventListener( KeyboardEvent.KEY_DOWN, keyDown ) ;
        }
        
        public var command:Batch ;
        
        public function keyDown( e:KeyboardEvent ):void
        {
            command.run() ;
        }
    }
}
}}}

When the user push the keyboard's key, the three square displays move in the same times, the batch run all this registered commands at once.

// TODO continue the reference (in progress)